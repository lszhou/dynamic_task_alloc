%--------------------CHAPTER 3-----------------------------
\chapter{Data Structure and Implementation}

% Some questions need to be answered?
% (1) In this thesis, what is the shared memory system Architecture, CC or DSM. (Pareek_MSc_15, Wojciech_201011_PhD_thesis_17)
% (2) What is shared memory object? and what is "the implementation" of a shared memory object?
% (3) Should the random(s), etc be assumed linearizable or atomic? what's the difference here? (Pareek_MSc_20)
% The classification of memory accesses into local and remote depends on the memory
% model of the multiprocessor: In the distributed shared memory (DSM) model, a variable’s
% physical address determines locality with respect to a processor, each variable being local
% to exactly one processor and remote to all others. In the cache-coherent (CC) model,
% processors operate on cached copies of shared variables, and it is the state of a processor’s
% local cache combined with the action of the coherence protocol (which keeps consistent
% copies of a variable in different caches) that determines locality. A memory access is
% local if it results in a cache hit and can be resolved without accessing main memory or
% a remote cache; a memory access is remote otherwise. To analyze the worst-case RMR
% complexity of an algorithm, we assume that each process runs on a distinct processor.
% (For this reason, we speak of processes and processors interchangeably.)


\section*{Data Structure}
\section*{The Implementation of Type DTA}

\begin{algorithm}
\caption{\texttt{DoTask()}}
\While {$true$}{
   $v \leftarrow root$;\\

   \If{$v.surplus() \leq 0$}{
   \Return $\perp$;\
   }
   \BlankLine
   /* Descent */\;
    \While{$v$ is not a leaf}{
        $(x_L, y_L) \leftarrow v.left.read()$\;
        $(x_R, y_R) \leftarrow v.right.read()$\;
        $s_L \leftarrow min(x_L-y_L, 2^{height(v)})$\;
        $s_R \leftarrow min(x_R-y_R, 2^{height(v)})$\;
        $r \leftarrow random(0,1)$\;

        \uIf{$(s_L+s_R)=0$}{
            Mark-up($v$)\;
        }
        \uElseIf{$r<s_L/(s_L+s_R)$}{
            $v \leftarrow v.left$\;
        }
        \Else{
            $v \leftarrow v.rght$\;
        }
    }

    \BlankLine
    /* $v$ is a leaf */\;
    $(x,y) \leftarrow v.read()$\;
    $(flag, l)$ $\leftarrow$ $v$.\texttt{TryTask}(task$[y+1]$)\;

    \BlankLine
    /* Update Insertion Count */\;
    $v$.CAS$((x, y), (x, y+1))$\;
    $v \leftarrow v.parent$\;
    Mark-up($v$)\;
    \If{$flag$ = $success$}{
        \Return $\ell$
    }
}
\end{algorithm}

%\begin{algorithm}
%\caption{DoTask()}               %����
%\label{alg1}                         %�����㷨�������������ط�����
%\begin{algorithmic}[1]
%\WHILE {(true)}
%   \STATE $v \leftarrow root$\\
%   \IF {($v.surplus() \leq 0$)}
%   \RETURN $\perp$
%   \ENDIF \\
%   \vspace{3mm}
%   /* Descent */
%   \WHILE {$v$ is not a leaf}
%       \STATE $(x_L, y_L) \leftarrow v.left.read()$\\
%       \STATE $(x_R, y_R) \leftarrow v.right.read()$\\
%       \STATE $s_L \leftarrow min(x_L-y_L, 2^{height(v)})$ \\
%       \STATE $s_R \leftarrow min(x_R-y_R, 2^{height(v)})$ \\
%       \STATE $r \leftarrow random(0,1)$
%       \IF {$((s_L+s_R)=0)$}
%           \STATE Mark-up($v$)
%       \ELSIF {($r<s_L/(s_L+s_R)$)}
%           \STATE $v \leftarrow v.left$
%       \ELSE
%           \STATE $v \leftarrow v.rght$
%       \ENDIF
%   \ENDWHILE
%   \vspace{3mm}\\
%   /* $v$ is a leaf */
%   \STATE $(x,y) \leftarrow v.read()$
%   \STATE $(flag, l)$ $\leftarrow$ $v$.TryTask(task$[y+1]$)
%   \STATE $v$.CAS$((x, y), (x, y+1))$    // Update Insertion Count
%   \STATE $v \leftarrow v.parent$
%   \STATE Mark-up($v$)
%   \IF {$flag$ = success}
%       \RETURN $\ell$
%   \ENDIF
%\ENDWHILE
%\end{algorithmic}
%\end{algorithm}



\begin{algorithm}
\caption{\texttt{InsertTask(}$\ell$\texttt{)}}
\While{$true$}{
    $v \leftarrow root$\;
    \BlankLine
    /* Descent */\;
    \While{$v$ is not a leaf}{
        $(x_L, y_L) \leftarrow v.left.read()$\;
        $(x_R, y_R) \leftarrow v.right.read()$\;
        $s_L \leftarrow 2^{height(v)} - min(x_L-y_L, 2^{height(v)})$\;
        $s_R \leftarrow 2^{height(v)} - min(x_R-y_R, 2^{height(v)})$\;
        $r \leftarrow random(0,1)$\;

        \uIf{$(s_L+s_R)=0$}{
            Mark-up($v$)\;
        }
        \uElseIf{$r<s_L/(s_L+s_R)$}{
            $v \leftarrow v.left$\;
        }
        \Else{
            $v \leftarrow v.rght$\;
        }
    }

    \BlankLine
    /* $v$ is a leaf */\;
    $(x,y) \leftarrow v.read()$\;
    $flag$ $\leftarrow$ $v$.\texttt{PutTask}(task$[x+1]$)\;

    \BlankLine
    /* Update Insertion Count */\;
    $v$.CAS$((x, y), (x+1, y))$\;
    $v \leftarrow v.parent$\;
    Mark-up($v$)\;
    \If{$flag$ = $success$}{
        \Return $success$
    }
}
\end{algorithm}



%\begin{algorithm}
%\caption{Insert(task $\ell$)}               %����
%\label{alg2}                         %�����㷨�������������ط�����
%\begin{algorithmic}[1]
%\WHILE {(true)}
%   \STATE $v \leftarrow root$\\
%   \vspace{3mm}
%   /* Descent */
%   \WHILE {($v$ is not a leaf)}
%       \STATE $(x_L, y_L) \leftarrow v.left.read()$\\
%       \STATE $(x_R, y_R) \leftarrow v.right.read()$\\
%       \STATE $s_L \leftarrow min(x_L-y_L, 2^{height(v)})$ \\
%       \STATE $s_R \leftarrow min(x_R-y_R, 2^{height(v)})$ \\
%       \STATE $r \leftarrow random(0,1)$
%       \IF {($(s_L+s_R) = 0$)}
%           \STATE Mark-up($v$)
%       \ELSIF {($r < s_L/(s_L + s_R)$)}
%           \STATE $v \leftarrow v.left$
%       \ELSE
%           \STATE $v \leftarrow v.rght$
%       \ENDIF
%   \ENDWHILE
%   \vspace{3mm}\\
%   /* $v$ is a leaf */
%   \STATE $(x,y) \leftarrow v.read()$
%   \STATE $flag$ $\leftarrow$ $v$.PutTask(task$[x+1]$, $\ell$)
%   \STATE $v$.CAS$((x,y), (x+1,y))$ // Update Insertion Count
%   \STATE $v \leftarrow v.parent$
%   \STATE Mark-up($v$)
%   \IF {($flag$ = success)}
%       \RETURN $success$
%   \ENDIF
%\ENDWHILE
%\end{algorithmic}
%\end{algorithm}



\begin{algorithm}
\caption{\texttt{Mark-up}($v$)}
\If{$v$ is not $null$}{
    \For {($i=0; i<2; i++$)}{
        $(x, y) \leftarrow v.read()$\;
        $(x_L, y_L) \leftarrow v.left.read()$\;
        $(x_R, y_R) \leftarrow v.right.read()$\;
        $v$.CAS$((x,y), (max(x, x_L + x_R), max(y, y_L + y_R))$\;
    }
}
\end{algorithm}



%
%\begin{algorithm}
%\caption{Mark-up($v$)}               %����
%\label{alg3}                         %�����㷨�������������ط�����
%\begin{algorithmic}[1]
%\IF{($v$ is not Null)}
%    \FOR {($i=0; i<2; i++$)}
%    \STATE $(x, y) \leftarrow v.read()$
%    \STATE $(x_L, y_L) \leftarrow v.left.read()$
%    \STATE $(x_R, y_R) \leftarrow v.right.read()$
%    \STATE $v$.CAS$((x,y), (max(x, x_L + x_R), max(y, y_L + y_R))$\\
%    \ENDFOR
%\ENDIF
%\end{algorithmic}
%\end{algorithm}
