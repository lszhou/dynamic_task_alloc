
%--------------------CHAPTER 2-----------------------------
\chapter{Computational Model and Definitions}
In this chapter, we will formally describe the computational model and give the definitions.

\section{Computational Model}
The computational model we consider is the standard asynchronous shared memory model with $n$ processes, each process has a unique identifier $i \in {1,...,n}$. The set of processes is denoted $\{p_1, p_2,...,p_n\}$ and up to $n-1$ processes may fail by crashing.

A \emph{shared object} is defined as a data structure with a well-defined set of states and a set of \emph{operation types}(\citep*{birnbaum1969new}). The state transition happens when an operation of an operation type is applied to shared object in a given state. Processes communicate with each other by applying operations on shared objects and receive corresponding response. Each process interacts with shared objects by applying the
operations to the objects. Each process executes its program by taking steps until it \emph{terminates} which means a special state is reached and the process takes no further action. A \emph{step} is defined to be the execution of shared memory operation on shared objects and receive corresponding response. 

Each shared object has a $type$ $\tau$ which can be defined as an automata (\cite{birnbaum1969new}) as follows,
$$\tau = (\mathcal{S}, s_{init},\mathcal{O},\mathcal{R} ,\delta )$$

where $\mathcal{S}$ is a set of states, $s_{init} \in \mathcal{S}$ is the initial state, $\mathcal{O}$ is a set of operation types, $\mathcal{R}$ is the set of responses, and $\delta :\mathcal{S} \times \mathcal{O} \to \mathcal{S} \times \mathcal{R}$ is a state transition mapping. 

In this thesis, we consider the system that supports atomic compare-and-swap (CAS) object. A CAS object $v$ is a shared memory object stores a value from some set and supports two atomic synchronization operations $v.$\texttt{read()} and $v.$\texttt{CAS(x,y)}. Operation $v.$\texttt{read()} returns the current value of $v$ and leaves the value unchanged. Operation $v.$\texttt{CAS(x,y)} writes new value into it only if it matches the given value $x$, i.e, if current value of $v$ equals $x$, then operation $v.$\texttt{CAS(x,y)} succeeds, and the value of $v$ is changed to be $y$ and $true$ is returned. Otherwise, the operation fails, and the current value of $v$ remains unchanged and $false$ is returned.

A process can execute local coin flip operation that returns an integer value distributed uniformly at random from an arbitrary finite set of integers. In the following discussion, we use \texttt{random(s)} to return a value which is distributed uniformly at random from set $\{0, 1, 2,..., s-1\}$. We analyze our algorithm under the assumption of a strong adaptive adversary. At any point of time, it can see the entire past history and know the states of all processes. Based on this information, it decides which process takes the next step.

Here are some more definition and terminology we need in our following discussion,
\theoremstyle{definition}

\begin{definition}{\textbf{History.}}
A history  (or execution) $H$, obtained by processes executing shared memory operations on concurrent objects, is a finite sequence of method invocation and response events.
\end{definition}

%A history $H$ may be related to several concurrent objects. When we consider the concurrency behavior of a specific object, we should focus on the subhistory of that object which is defined as follows:

\begin{definition}
$H|obj$ of history $H$ is the subsequence of all invocation and response events in $H$ whose object names are all $obj$.
\end{definition}

If all invocation and response events in a history $H$ have the same object name $obj$, then the $H|obj = H$. Thus, in the following discussion, when we discuss the concurrency behavior of a specific objet $obj$, the history $H$ and $H|obj$ are the same.

We use $inv_H(op)$ to denote the position of the invocation of operation $op$ in history $H$. Similarly we use $rep_H(op)$ to denote the position of the corresponding response of $op$ in $H$. Actually, for each operation $op$, it is not necessary to have a matching response. In this case, we call the operation $op$ is pending and denote it as $rsp_H(op) = \infty$. Otherwise, we call the operation is complete in $H$.

\begin{definition}{\textbf{Complete History}.}
A history is complete if all its operations are complete. A completion of an incomplete history $H$ is an extension $H'$ of $H$, such that $H'$ contains exactly the same operations as $H$ but the responses are added for the pending operations in $H$.
\end{definition}

Let $H$ be a complete history. With each operation $op$ in $H$ we could associate a time interval $I_H(op) = [inv(op), rsp(op)]$. Similarly, for an uncomplete history, we denote the interval with respect to the pending operation $op$ by $I_H(op) = [inv(op), \infty]$.

\begin{definition}{\textbf{Sequential History}.}
A history is sequential if the first event in the history is an invocation, and each invocation, except possibly the last one, is immediately followed by a corresponding response.
\end{definition}

It is obvious that a sequential history defines a total order over all operations.

\begin{definition}{\textbf{Sequential Specification}.}
The sequential specification $S_{obj}$ for a shared object $obj$ is a set of sequential histories on $obj$.
\end{definition}

We say a sequential history $S$ satisfies the sequential specification $S_{obj}$ of object $obj$, it means $S \in S_{obj}$. A sequential history $S$ of object $obj$ is valid (sometimes also called legal) if it satisfies the sequential specification of $obj$.

With the above definitions, we could now define linearization as follows:

\begin{definition}{\textbf{Linearization}.}
A history $H$ linearizes to a sequential history $S$, if and only if $S$ satisfies the following conditions: (1) $S$ and the completion of $H$ have the same operations, (2) sequential history $S$ is valid, and (3) there is a mapping from each time interval $I_H(op)$ to a time point $t_H(op) \in I_H(op)$, such that the sequential history $S$ could be obtained by sorting the operations in $H$ by their $t_H(op)$ values.
\end{definition}

A history is linearizable if and only if there exists a sequential history $S$ that linearizes $H$. In this case, $S$ is called linearization of $H$.

We choose one linearization of $H$ and this linearization defines $t_H(op)$. For each operation $op$ in history $H$, we call the point $t_H(op)$ linearization point of $op$.

\begin{definition}{\textbf{Linearizable Object}.}
A shared object is linearizable if every history $H$ of that object is linearizable.
\end{definition}



