
%--------------------CHAPTER 2-----------------------------
\chapter{Model of Computation and Definitions}
In this chapter, we will describe our model of computation and give the definitions, which are based on Herlihy
and Wing's \cite{Herlihy:1990:LCC:78969.78972} and Golab, Hadzilacos and Woelfel's \cite{InProc-GHHW2007a}.

The computational model we consider is the standard asynchronous shared memory model with a set of $n$ processes,
denoted as $\{p_1, p_2,...,p_n\}$ , where up to $n-1$ processes may fail by crashing.


\textbf{Type and Object}.
A \emph{type} $\tau$ could be defined as an automaton as follows \cite{InProc-GHHW2007a},
$$\tau = (\mathcal{S}, s_{init},\mathcal{O},\mathcal{R} ,\delta )$$

where $\mathcal{S}$ is a set of states, $s_{init} \in \mathcal{S}$ is the initial state, $\mathcal{O}$ is a set of
operation types, $\mathcal{R}$ is the set of responses, and
$\delta :\mathcal{S} \times \mathcal{O} \to \mathcal{S} \times \mathcal{R}$ is a one-to-many state transition mapping.

An \emph{object} is an implementation of a type. For each type $\tau$, the transition mapping $\delta$ captures the
behaviour of objects of type $\tau$, in the absence of concurreny,
as follows: if a process applies an operation of type $opt$ to an object of type $\tau$ which is in state $s$, the the object
may return to the process a response $r$ and change its states to $s'$ if and only if $(s', r) \in \delta(s, opt)$.

An object supports only \texttt{read()} and \texttt{write(x)} operations is called a \emph{read/write register}
(or just \emph{register}). Operation \texttt{read()} returns the current state of register and leaves the state unchanged.
Operation \texttt{write(x)} changes the state of register to be $x$.

An object supports \texttt{read()} and \texttt{CAS(x,y)} operations is called \emph{compare-and-swap} (CAS) object.
Operation \texttt{CAS(x,y)} changes the state of the obejct if and only if the current state is equal to the given state $x$, i.e,
if current state equals $x$, then operation \texttt{CAS(x,y)} succeeds, and the state is changed
to be $y$ and $true$ is returned. Otherwise, operation \texttt{CAS(x,y)} fails, the current state remains unchanged and
$false$ is returned.

\textbf{History}
A \emph{history} $H$, obtained by processes executing
operations on objects, is a sequence of operation \emph{invocation event} $INV$
and \emph{response events} $RSP$.
An invocation event $INV$ of operation type $opt$ where process $p$ invokes operation on object
$obj$ is defined as a 5-tuple
$$INV = (invocation, p, obj, opt, t)$$
where $invocation$ is the event type and
$t$ is the order of event $INV$ in history $H$. We also call $t$ is the \emph{time} when $INV$ happens.

A response event $RSP$ where process $p$ receives response $rsp$ from an operation execution on object $obj$
is defined as
$$(response, p, obj, rsp, t)$$
where $response$ is the event type, $t$ is the order of event $INV$
in history $H$. We also call $t$ is the time when $INV$ happens.

Response event $(response, p_j, obj_q, rsp, t_1)$ \emph{matches} invocation event $(invocation, p_i, obj_p, opt, t_0)$
in history $H$, if the two events are applied by the same process to the same object, i.e, $i = j$ and $p = q$.
The response event is also called the $matching$ response of the invocation event.

An \emph{operation execution} in $H$ is a pair $oe = (INV, RSP)$ consisting of an invocation event $INV$
and the next matching response event $RSP$, or just an invocation event $INV$, denoted as $oe = (INV, null)$.
For the latter case, we call the operation execution is \emph{pending}. For the former case, we call the operation
execution is \emph{complete}. A history $H$ is \emph{complete} if all operation executions in $H$ are \emph{complete},
otherwise, it is \emph{incomplete}.

History $H'$ is an extension of history $H$ if $H$ is the prefix of $H'$.
History $H'$ is called the \emph{completion} of incomplete history $H$ if $H'$, containing the same
events as $H$, is an extension of $H$ and each operation in $H'$ is complete.

$H|obj$ of history $H$ is the subsequence of all
invocation and response events in $H$ on object $obj$. If all invocation and response
events in a history $H$ have the same object name $obj$, then the $H|obj = H$. Thus, in the following discussion,
when we discuss the concurrency behavior of a specific objet $obj$, the history $H$ and $H|obj$ are the same.

Let $H$ be a complete history, we could associate a time interval $I_{(INV, RSP)} = [t_0, t_1]$ with each
operation execution $(INV, RSP)$ in $H$, where $t_0$ and $t_1$ is the time point when $INV$ and $RSP$ happen
respectively. Similarly, for an uncomplete history, we denote the time interval $I_{(INV, RSP)}$ with respect to the pending
operation execution by $I_{(INV, RSP)} = [t_0, \infty]$.

Operation execution $oe_0$ \emph{precedes} operation execution $oe_1$ in $H$ if the response event of
$oe_0$ happens before the invocation event of $oe_1$ in $H$.
We say that $oe_0$ and $oe_1$ are \emph{concurrent} in $H$ if neither precedes the other.

A history is \emph{sequential} if the first event is an invocation event, and each invocation event, except
possibly the last one, is immediately followed by a matching response event.

\textbf{Linearization.}
A history $H$ \emph{linearizes} to a sequential history $S$, if and only if $S$ satisfies the
following conditions: (1) $S$ and any completion of $H$ have the same operations, (2) sequential history $S$ is
valid, and (3) there is a mapping from each time interval $I_{(INV, RSP)}$ to a time point $t_{(INV, RSP)} \in I_{(INV, RSP)}$, such
that the sequential history $S$ is obtained by sorting the operations in $H$ based on their $t_{(INV, RSP)}$ values.

A history is \emph{linearizable} if and only if $H$ linearizes to some sequential history $S$. In this case,
$S$ is called the \emph{linearization} of $H$. For each operation $opt$ in history $H$, we call the time point $t_{(INV, RSP)}$
the \emph{linearization point} of $opt$. An object $obj$ is linearizable if every history $H$ on $obj$ is linearizable.

\textbf{Randomness}.
A process can execute local coin flip operation that returns an integer value distributed
uniformly at random from an arbitrary finite set of integers. In the following discussion, we use method
\texttt{random(s)} to return a value which is distributed uniformly at random from set $\{0, 1, 2,..., s-1\}$.

\textbf{Adversary}.
We analyze our algorithm under the assumption of a strong adaptive adversary. At any
point of time, it can see the entire past history and know the states of all processes.

(\emph{What a process do to execute a program? What is an adversary? What is the functionality of an adversary? (to schedule processes )?
How it schedules processes?})


%========================== Update log =================
% Aug.27
% -change some items like from "value" to "state"
% -compeletion of a imcomplete history definition.
% -some typos
